package it.unica.co2.site.storerec;


import static it.unica.co2.api.contract.utils.ContractFactory.*;
import it.unica.co2.api.contract.ContractDefinition;
import it.unica.co2.api.contract.Recursion;
import it.unica.co2.api.contract.SessionType;
import it.unica.co2.api.contract.Sort;
import it.unica.co2.api.process.CO2Process;
import it.unica.co2.api.process.Participant;
import it.unica.co2.honesty.HonestyChecker;
import co2api.ContractException;
import co2api.ContractExpiredException;
import co2api.Message;
import co2api.Public;
import co2api.Session;
import co2api.SessionI;
import co2api.TimeExpiredException;

/*
 * auto-generated by co2-plugin
 * creation date: 02-12-2016 15:23:53
 */
@SuppressWarnings("unused")
public class Main {
	
	private static final String username = "eclipse@co2.unica.it";
	private static final String password = "eclipse";
	
	static final Integer intPlaceholder = 42;
	static final String stringPlaceholder = "42";
	
	
	/*
	 * contracts declaration
	 */
	static final ContractDefinition Crec = def("Crec");
	static final ContractDefinition D = def("D");
	
	/*
	 * contracts initialization
	 */
	static {
		Crec.setContract(externalSum().add("addToCart", Sort.string(), ref(Crec)).add("checkout", Sort.unit(), internalSum().add("price", Sort.integer(), externalSum().add("accept", Sort.unit()).add("reject", Sort.unit())).add("unavailable", Sort.unit())));
		D.setContract(internalSum().add("req", Sort.string(), externalSum().add("ok", Sort.unit()).add("no", Sort.unit())));
	}
	
	
	public static class StoreRec extends Participant {
		
		private static final long serialVersionUID = 1L;
		
		public StoreRec(String username, String password) {
			super(username, password);
		}
		
		@Override
		public void run() {
			Session<SessionType> x = tellAndWait(Main.Crec);
			
			processCall(Loop.class, username, password ,x); 
		}
	}
	
	public static class Loop extends Participant {
		
		private static final long serialVersionUID = 1L;
		private SessionI<SessionType> x;
		
		public Loop(String username, String password, SessionI<SessionType> x) {
			super(username, password);
			this.x=x;
		}
		
		@Override
		public void run() {
			logger.info("waiting on 'x' for actions [addToCart, checkout]");
			Message msg = x.waitForReceive("addToCart", "checkout"); 
			
			switch (msg.getLabel()) {
				case "addToCart":
					logger.info("received ["+msg.getLabel()+"]");
					String item;
					item = msg.getStringValue();
					processCall(Loop.class, username, password ,x); 
					break;
				case "checkout":
					logger.info("received ["+msg.getLabel()+"]");
					processCall(Checkout.class, username, password ,x); 
					break;
			}
		}
	}
	
	public static class Checkout extends Participant {
		
		private static final long serialVersionUID = 1L;
		private SessionI<SessionType> x;
		
		public Checkout(String username, String password, SessionI<SessionType> x) {
			super(username, password);
			this.x=x;
		}
		
		@Override
		public void run() {
			Public<SessionType> pbl_y = tell(Main.D, Main.intPlaceholder*1000); 
			
			try {
				Session<SessionType> y = pbl_y.waitForSession();
				
				logger.info("sending action 'req'");
				y.sendIfAllowed("req", Main.stringPlaceholder); //TODO: remove the placeholder/s
				
				try {
					logger.info("waiting on 'y' for actions [ok, no]");
					Message msg = y.waitForReceive(Main.intPlaceholder*1000, "ok", "no"); //TODO: remove the placeholder/s
					
					switch (msg.getLabel()) {
						case "ok":
							logger.info("received ["+msg.getLabel()+"]");
							logger.info("sending action 'price'");
							x.sendIfAllowed("price", Main.intPlaceholder); //TODO: remove the placeholder/s
							
							logger.info("waiting on 'x' for actions [accept, reject]");
							Message msg1 = x.waitForReceive("accept", "reject"); 
							
							switch (msg1.getLabel()) {
								case "accept":
									logger.info("received ["+msg1.getLabel()+"]");
									break;
								case "reject":
									logger.info("received ["+msg1.getLabel()+"]");
									break;
							}
							break;
						case "no":
							logger.info("received ["+msg.getLabel()+"]");
							logger.info("sending action 'unavailable'");
							x.sendIfAllowed("unavailable"); 
							break;
					}
				}
				catch (TimeExpiredException e) {
					
					parallel(()->{
						logger.info("sending action 'unavailable'");
						x.sendIfAllowed("unavailable"); 
					});
					
					parallel(()->{
						logger.info("waiting on 'y' for actions [ok, no]");
						Message msg2 = y.waitForReceive("ok", "no"); 
						
						switch (msg2.getLabel()) {
							case "ok":
							case "no":
								logger.info("received ["+msg2.getLabel()+"]");
								break;
						}
					});
				}
				
			}
			catch(ContractExpiredException e1) {
				//retract y
				logger.info("sending action 'unavailable'");
				x.sendIfAllowed("unavailable"); 
			}
		}
	}
	
	public static void main(String[] args) {
		HonestyChecker.isHonest(StoreRec.class, Main.username, Main.password);
		//new Thread(new StoreRec(Main.username, Main.password)).start();
	}
}
