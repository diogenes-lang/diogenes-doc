package it.unica.co2.site.blackjack;


import static it.unica.co2.api.contract.utils.ContractFactory.*;
import it.unica.co2.api.contract.ContractDefinition;
import it.unica.co2.api.contract.Recursion;
import it.unica.co2.api.contract.SessionType;
import it.unica.co2.api.contract.Sort;
import it.unica.co2.api.process.CO2Process;
import it.unica.co2.api.process.Participant;
import it.unica.co2.honesty.HonestyChecker;
import co2api.ContractException;
import co2api.ContractExpiredException;
import co2api.Message;
import co2api.Public;
import co2api.Session;
import co2api.SessionI;
import co2api.TimeExpiredException;

/*
 * auto-generated by co2-plugin
 * creation date: 02-12-2016 15:25:41
 */
@SuppressWarnings("unused")
public class Main {
	
	private static final String username = "eclipse@co2.unica.it";
	private static final String password = "eclipse";
	
	static final Integer intPlaceholder = 42;
	
	
	/*
	 * contracts declaration
	 */
	static final ContractDefinition Cp = def("Cp");
	static final ContractDefinition Cd = def("Cd");
	
	/*
	 * contracts initialization
	 */
	static {
		Cp.setContract(externalSum().add("hit", Sort.unit(), internalSum().add("card", Sort.integer(), ref(Cp)).add("lose", Sort.unit()).add("abort", Sort.unit())).add("stand", Sort.unit(), internalSum().add("win", Sort.unit()).add("lose", Sort.unit()).add("abort", Sort.unit())));
		Cd.setContract(internalSum().add("next", Sort.unit(), externalSum().add("card", Sort.integer(), ref(Cd))).add("abort", Sort.unit()));
	}
	
	
	public static class P extends Participant {
		
		private static final long serialVersionUID = 1L;
		
		public P(String username, String password) {
			super(username, password);
		}
		
		@Override
		public void run() {
			Session<SessionType> xd = tellAndWait(Main.Cd);
			
			Public<SessionType> pbl_xp = tell(Main.Cp, Main.intPlaceholder*1000); 
			
			try {
				Session<SessionType> xp = pbl_xp.waitForSession();
				
				processCall(Pplay.class, username, password ,xp, xd, 0); 
			}
			catch(ContractExpiredException e) {
				//retract xp
				logger.info("sending action 'abort'");
				xd.sendIfAllowed("abort"); 
			}
		}
	}
	
	public static class Pplay extends Participant {
		
		private static final long serialVersionUID = 1L;
		private SessionI<SessionType> xp;
		private SessionI<SessionType> xd;
		private Integer np;
		
		public Pplay(String username, String password, SessionI<SessionType> xp, SessionI<SessionType> xd, Integer np) {
			super(username, password);
			this.xp=xp;
			this.xd=xd;
			this.np=np;
		}
		
		@Override
		public void run() {
			try {
				logger.info("waiting on 'xp' for actions [hit, stand]");
				Message msg = xp.waitForReceive(Main.intPlaceholder*1000, "hit", "stand"); //TODO: remove the placeholder/s
				
				switch (msg.getLabel()) {
					case "hit":
						logger.info("received ["+msg.getLabel()+"]");
						logger.info("sending action 'next'");
						xd.sendIfAllowed("next"); 
						
						processCall(Pdeck.class, username, password ,xp, xd, np); 
						break;
					case "stand":
						logger.info("received ["+msg.getLabel()+"]");
						processCall(Qstand.class, username, password ,xp, xd, np, 0); 
						break;
				}
			}
			catch (TimeExpiredException e) {
				logger.info("sending action 'abort'");
				xd.sendIfAllowed("abort"); 
				
				processCall(PabortP.class, username, password ,xp); 
			}
			
		}
	}
	
	public static class Pdeck extends Participant {
		
		private static final long serialVersionUID = 1L;
		private SessionI<SessionType> xp;
		private SessionI<SessionType> xd;
		private Integer np;
		
		public Pdeck(String username, String password, SessionI<SessionType> xp, SessionI<SessionType> xd, Integer np) {
			super(username, password);
			this.xp=xp;
			this.xd=xd;
			this.np=np;
		}
		
		@Override
		public void run() {
			try {
				logger.info("waiting on 'xd' for actions [card]");
				Message msg = xd.waitForReceive(Main.intPlaceholder*1000, "card"); //TODO: remove the placeholder/s
				
				logger.info("received [card]");
				Integer n;
				try {
					n = Integer.parseInt(msg.getStringValue());
				}
				catch (NumberFormatException e) {
					throw new RuntimeException(e);
				}
				processCall(Pcard.class, username, password ,xp, xd, (np+n), n); 
			}
			catch (TimeExpiredException e1) {
				logger.info("sending action 'abort'");
				xp.sendIfAllowed("abort"); 
				
				processCall(PabortD.class, username, password ,xd); 
			}
			
		}
	}
	
	public static class Pcard extends Participant {
		
		private static final long serialVersionUID = 1L;
		private SessionI<SessionType> xp;
		private SessionI<SessionType> xd;
		private Integer np;
		private Integer n;
		
		public Pcard(String username, String password, SessionI<SessionType> xp, SessionI<SessionType> xd, Integer np, Integer n) {
			super(username, password);
			this.xp=xp;
			this.xd=xd;
			this.np=np;
			this.n=n;
		}
		
		@Override
		public void run() {
			if ((np<21)) { 
				logger.info("sending action 'card'");
				xp.sendIfAllowed("card", n); 
				
				processCall(Pplay.class, username, password ,xp, xd, np); 
			}
			else {
				logger.info("sending action 'lose'");
				xp.sendIfAllowed("lose"); 
				
				processCall(PabortD.class, username, password ,xd); 
			}
		}
	}
	
	public static class Qstand extends Participant {
		
		private static final long serialVersionUID = 1L;
		private SessionI<SessionType> xp;
		private SessionI<SessionType> xd;
		private Integer np;
		private Integer nd;
		
		public Qstand(String username, String password, SessionI<SessionType> xp, SessionI<SessionType> xd, Integer np, Integer nd) {
			super(username, password);
			this.xp=xp;
			this.xd=xd;
			this.np=np;
			this.nd=nd;
		}
		
		@Override
		public void run() {
			if ((nd<21)) { 
				logger.info("sending action 'next'");
				xd.sendIfAllowed("next"); 
				
				processCall(Qdeck.class, username, password ,xp, xd, np, nd); 
			}
			else {
				logger.info("sending action 'win'");
				xp.sendIfAllowed("win"); 
				
				logger.info("sending action 'abort'");
				xd.sendIfAllowed("abort"); 
			}
		}
	}
	
	public static class Qdeck extends Participant {
		
		private static final long serialVersionUID = 1L;
		private SessionI<SessionType> xp;
		private SessionI<SessionType> xd;
		private Integer np;
		private Integer nd;
		
		public Qdeck(String username, String password, SessionI<SessionType> xp, SessionI<SessionType> xd, Integer np, Integer nd) {
			super(username, password);
			this.xp=xp;
			this.xd=xd;
			this.np=np;
			this.nd=nd;
		}
		
		@Override
		public void run() {
			try {
				logger.info("waiting on 'xd' for actions [card]");
				Message msg = xd.waitForReceive(Main.intPlaceholder*1000, "card"); //TODO: remove the placeholder/s
				
				logger.info("received [card]");
				Integer n;
				try {
					n = Integer.parseInt(msg.getStringValue());
				}
				catch (NumberFormatException e) {
					throw new RuntimeException(e);
				}
				processCall(Qcard.class, username, password ,xp, xd, np, nd); 
			}
			catch (TimeExpiredException e1) {
				logger.info("sending action 'abort'");
				xp.sendIfAllowed("abort"); 
				
				processCall(PabortD.class, username, password ,xd); 
			}
			
		}
	}
	
	public static class Qcard extends Participant {
		
		private static final long serialVersionUID = 1L;
		private SessionI<SessionType> xp;
		private SessionI<SessionType> xd;
		private Integer np;
		private Integer nd;
		
		public Qcard(String username, String password, SessionI<SessionType> xp, SessionI<SessionType> xd, Integer np, Integer nd) {
			super(username, password);
			this.xp=xp;
			this.xd=xd;
			this.np=np;
			this.nd=nd;
		}
		
		@Override
		public void run() {
			if ((nd<np)) { 
				processCall(Qstand.class, username, password ,xp, xd, np, nd); 
			}
			else {
				logger.info("sending action 'lose'");
				xp.sendIfAllowed("lose"); 
				
				processCall(PabortD.class, username, password ,xd); 
			}
		}
	}
	
	public static class PabortP extends Participant {
		
		private static final long serialVersionUID = 1L;
		private SessionI<SessionType> xp;
		
		public PabortP(String username, String password, SessionI<SessionType> xp) {
			super(username, password);
			this.xp=xp;
		}
		
		@Override
		public void run() {
			logger.info("waiting on 'xp' for actions [hit, stand]");
			Message msg = xp.waitForReceive("hit", "stand"); 
			
			switch (msg.getLabel()) {
				case "hit":
				case "stand":
					logger.info("received ["+msg.getLabel()+"]");
					logger.info("sending action 'abort'");
					xp.sendIfAllowed("abort"); 
					break;
			}
		}
	}
	
	public static class PabortD extends Participant {
		
		private static final long serialVersionUID = 1L;
		private SessionI<SessionType> xd;
		
		public PabortD(String username, String password, SessionI<SessionType> xd) {
			super(username, password);
			this.xd=xd;
		}
		
		@Override
		public void run() {
			
			parallel(()->{
				logger.info("sending action 'abort'");
				xd.sendIfAllowed("abort"); 
			});
			
			parallel(()->{
				logger.info("waiting on 'xd' for actions [card]");
				Message msg = xd.waitForReceive("card"); 
				
				logger.info("received [card]");
				Integer n;
				try {
					n = Integer.parseInt(msg.getStringValue());
				}
				catch (NumberFormatException e) {
					throw new RuntimeException(e);
				}
				logger.info("sending action 'abort'");
				xd.sendIfAllowed("abort"); 
			});
		}
	}
	
	public static void main(String[] args) {
		HonestyChecker.isHonest(P.class, Main.username, Main.password);
		//new Thread(new P(Main.username, Main.password)).start();
	}
}
